---
layout: post
title: "APP启动流程与优化"
author: "李萌"
categories: note
tags: [note]
feature-img: "assets/img/article/main.jpg"
thumbnail: "assets/img/article/main.jpg"
---
当用户点击了App图标，到能够看到App主界面内容为止，在这个过程中应用做了那些事情呢？这些事情是否可以优化从而提高启动速度呢？下面我们将会讨论以上问题。

### main()之前

在调用`main()`函数之前，基本所有工作都是由操作系统完成的，开发者能够插手的地方不多，多以如果想要想要优化这段时间，就必须了解，操作系统在`main()`之前做了什么。

`main()`之前操作系统所做的工作是把可执行文件（Mach-O格式）加载到内存空间，然后动态链接库dyld，再执行一系列动态链接操作和初始化操作的过程（加载、绑定。及初始化）。

#### 加载过程—从exec()到main()

![main-load](https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/main-load.png)

- `exec()`是一个系统调用
- App对应的可执行文件加载到内存
- 把`Dyld`加载到内存中，`Dyld：the dynamic link editor`所有动态链接库和我们App的静态库.a和所有类文件编译后.o文件，最终都由dyld加载到内存的.
- `Dyld`从主执行文件的`header`获取到需要加载的所依赖动态库列表，然后它需要找到每个`dylib`，而用所依赖的`dylib`文件可能会再依赖其他`dylib`，所以所需要加载的是动态库列表的一个递归依赖集合
- `Rebase`和`Bind`
  - `Rebase`在`Image`内部调整指针的指向。在过去会把动态库加载到指定地址，所有指针和数据对于代码都是对的，而现在地址空间布局是随机化，所以需要在原来的地址根据随机的偏移量做一下修正
  - `Bind`是吧指针正确地指向`Image`外部的内容。这些指向外部的指针被符号(`symbol`)名称绑定，`Dyld`需要去符号表里查找，找到`symbol`对应的实现。
- `Objc`
- 注册`Objc`类（class registration）
  
- 把`category`的定义插入方法列表（category registration）
  
- 保证每一个`selector`唯一（selector uniquing）
- `initializers`
  - `Objc`的`+load()`函数
  - `C++`的构造函数属性函数
  - 非基本类型的`C++`静态全局变量的创建(通常是类或者结构体)

最后，`Dyld`会调用`mian()`函数，`mian()`会调用`UIApplicationMain()`。

了解完`main()`之前的加载过程后，我们可以分析出影响`main`调用前启动时间的因素：

1. 动态库加载越多，启动越慢
2. `Objc`类，方法越多，启动越慢
3. `Objc`的`+load()`越多，启动越慢
4. `C`的`constructor`函数越多，启动越慢
5. `C++`静态对象越多，启动越慢

#### main()之前启动优化

- 代码瘦身：清理工程中无用的代码和文件，这样能够减少App的包大小，也加快App的启动速度
- `+load()`优化：`+load`方法在`Initializers`阶段被执行，但过多`+load`方法则会拖慢启动速度，一些不是必须放入`+load`方法的内容可以在启动后的合适时机进行处理，以加快启动时间。

### main()函数之后

`main()`函数之后，即从`main()`开始，到`AppDelegate`的`didFinishLaunchingWithOptions`方法执行完毕，至App初始化完成，首页请求、首页渲染等过程后，用户看到界面为止。

#### 优化耗时操作

Time Profiler : Time Profiler是Xcode自带的时间性能分析工具，它按照固定的时间间隔来跟踪每一个线程的堆栈信息，通过统计比较时间间隔之间的堆栈状态，来推算某个方法执行了多久，并获得一个近似值。通过它来进行性能分析，从而优化耗时操作。

#### 优化串行操作

在冷启动过程中，有很多操作是串行执行的，若干个任务串行执行，时间必然比较长。如果能变串行为并行，那么冷启动时间就能够大大缩短。

