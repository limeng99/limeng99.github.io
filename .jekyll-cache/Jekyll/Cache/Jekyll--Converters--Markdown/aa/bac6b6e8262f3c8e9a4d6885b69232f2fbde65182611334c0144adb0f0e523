I"Zg<p>Runtime的特性主要是消息(<code class="highlighter-rouge">方法</code>)传递，如果消息(<code class="highlighter-rouge">方法</code>)在对象中找不到，就进行转发，具体怎么实现的呢。我们从下面几个方面探寻Runtime的实现机制。</p>

<h3 id="runtime介绍">Runtime介绍</h3>

<blockquote>
  <p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。</p>
</blockquote>

<blockquote>
  <p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。</p>
</blockquote>

<p><code class="highlighter-rouge">Runtime</code> 基本是用 <code class="highlighter-rouge">C</code> 和<code class="highlighter-rouge">汇编</code>写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="http://www.opensource.apple.com/source/objc4/">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的 <a href="https://github.com/RetVal/objc-runtime">runtime</a> 版本，这两个版本之间都在努力的保持一致。</p>

<p>平时的业务中主要是使用<a href="https://developer.apple.com/reference/objectivec/objective_c_runtime#//apple_ref/doc/uid/TP40001418-CH1g-126286">官方Api</a>，解决我们框架性的需求。</p>

<p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是<code class="highlighter-rouge">OC</code>并不能直接编译为汇编语言，而是要先转写为纯<code class="highlighter-rouge">C</code>语言再进行编译和汇编的操作，从<code class="highlighter-rouge">OC</code>到<code class="highlighter-rouge">C</code>语言的过渡就是由runtime来实现的。然而我们使用<code class="highlighter-rouge">OC</code>进行面向对象开发，而<code class="highlighter-rouge">C</code>语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。</p>

<h3 id="runtime消息传递">Runtime消息传递</h3>

<p>一个对象的方法像这样<code class="highlighter-rouge">[obj message]</code>，编译器转成消息发送<code class="highlighter-rouge">objc_msgSend(obj, message)</code>，<code class="highlighter-rouge">Runtime</code>时执行流程是这样的：</p>

<ul>
  <li>首先，通过<code class="highlighter-rouge">obj</code>的<code class="highlighter-rouge">isa</code>指针找到它的<code class="highlighter-rouge">classs</code>；</li>
  <li>在<code class="highlighter-rouge">class</code>的<code class="highlighter-rouge">method list</code>找<code class="highlighter-rouge">messge</code>；</li>
  <li>如果<code class="highlighter-rouge">class</code>中没有找到<code class="highlighter-rouge">messge</code>，继续往它的<code class="highlighter-rouge">superclass</code>中找；</li>
  <li>一旦找到<code class="highlighter-rouge">message</code>这个函数，就去执行它的实现<code class="highlighter-rouge">IMP</code>。</li>
</ul>

<p>但这种实现存在问题，效率低。因为一个<code class="highlighter-rouge">class</code>通常只有<code class="highlighter-rouge">20%</code>的函数会经常被调用，可能占总调用次数的<code class="highlighter-rouge">80%</code>。每个消息都需要遍历一次<code class="highlighter-rouge">objc_method_list</code>并不合理。而<code class="highlighter-rouge">objc_class</code>中另外一个重要成员<code class="highlighter-rouge">objc_cache</code>就会消除上述问题，在找到<code class="highlighter-rouge">message</code>之后，会把<code class="highlighter-rouge">message</code>的<code class="highlighter-rouge">method_name</code>作为<code class="highlighter-rouge">key</code>，<code class="highlighter-rouge">method_imp</code>作为<code class="highlighter-rouge">value</code>存储起来。当再次受到<code class="highlighter-rouge">message</code>消息的时候，就可以直接在<code class="highlighter-rouge">objc_cache</code>里找到，避免去遍历<code class="highlighter-rouge">objc_method_list</code>。</p>

<p><code class="highlighter-rouge">objc_msgSend</code>的方法定义如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ )
</code></pre></div></div>

<p>那么消息传递是怎么实现的呢？我们看看对象(<code class="highlighter-rouge">object</code>)，类(<code class="highlighter-rouge">class</code>)，方法(<code class="highlighter-rouge">method</code>)这几个结构体：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 对象
struct objc_object {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
};

// 类
struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif
} OBJC2_UNAVAILABLE;

// 方法列表
struct objc_method_list {
    struct objc_method_list * _Nullable obsolete             OBJC2_UNAVAILABLE;
    int method_count                                         OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE

// 方法
struct objc_method {
    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;
    char * _Nullable method_types                            OBJC2_UNAVAILABLE;
    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;
</code></pre></div></div>

<ol>
  <li>
    <p>系统首先找到消息的接收对象，然后通过对象<code class="highlighter-rouge">isa</code>指针找到它的类<code class="highlighter-rouge">class</code>。</p>
  </li>
  <li>
    <p>在它的类中查找<code class="highlighter-rouge">method_list</code>，是否有<code class="highlighter-rouge">selector</code>方法。</p>
  </li>
  <li>
    <p>没有则查找父类的<code class="highlighter-rouge">method_list</code>。</p>
  </li>
  <li>
    <p>找到对应的<code class="highlighter-rouge">method</code>，执行它的<code class="highlighter-rouge">IMP</code>。</p>
  </li>
  <li>
    <p>转发<code class="highlighter-rouge">IMP</code>的<code class="highlighter-rouge">return</code>值。</p>
  </li>
</ol>

<h4 id="类对象objc_class">类对象(objc_class)</h4>

<p><code class="highlighter-rouge">Objective-C</code>类是由<code class="highlighter-rouge">Class</code>类型来表示的，它实际上是一个指向<code class="highlighter-rouge">objc_class</code>结构体的指针。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct objc_class *Class;
</code></pre></div></div>

<p>查看<code class="highlighter-rouge">objc/runtime.h</code>中<code class="highlighter-rouge">objc_class</code>结构体定义如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
    
#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
</code></pre></div></div>

<p><code class="highlighter-rouge">struct objc_class</code>结构体里保存了指向父类的指针、类的名称、版本、实例大小、实例变量列表，方法列表、缓存、遵循协议列表等。
类对象就是一个结构体<code class="highlighter-rouge">struct objc_class</code>，这个结构体存放的数据成为元数据(<code class="highlighter-rouge">metadata</code>)。
该结构体的第一个成员变量<code class="highlighter-rouge">isa</code>指针，这就说明类本身其实也是一个对象，因此我们称<code class="highlighter-rouge">objc_class</code>其为类对象，类对象在编译期产生用于创建实例对象，类对象是单例。</p>

<h4 id="实例对象objc_object">实例对象(objc_object)</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct objc_object {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
};

typedef struct objc_object *id;
</code></pre></div></div>

<p>实例对象中<code class="highlighter-rouge">isa</code>指针指向类对象<code class="highlighter-rouge">objc_class</code>。
类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？
就是从<code class="highlighter-rouge">isa</code>指针指向的结构体创建，类对象的<code class="highlighter-rouge">isa</code>指针</p>

<h4 id="元类meta-class">元类(Meta Class)</h4>

<p><img src="https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/runtime-meta.png" alt="runtime-meta" /></p>

<p>通过上图我们可以看出整个体系构成了一个自闭环，<code class="highlighter-rouge">struct objc_object</code>结构体<code class="highlighter-rouge">实例</code>它的<code class="highlighter-rouge">isa</code>指针指向类对象；
类对象的<code class="highlighter-rouge">isa</code>指针指向了元类，<code class="highlighter-rouge">super_class</code>指针指向父类的类对象；
而元类的<code class="highlighter-rouge">super_class</code>指针指向了父类的元类，那元类的<code class="highlighter-rouge">isa</code>指针又指向了<code class="highlighter-rouge">NSObject元类</code>；
<code class="highlighter-rouge">NSObject</code>的元类<code class="highlighter-rouge">meta-class</code>的<code class="highlighter-rouge">super_class</code>指针指向了<code class="highlighter-rouge">NSObject类对象</code>，<code class="highlighter-rouge">isa</code>指针指向了自己。</p>

<p>元类(Meta Class)是一个类对象的类。
所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。
为了调用类方法，这个类的<code class="highlighter-rouge">isa</code>指针必须指向一个包含这些类方法的一个<code class="highlighter-rouge">objc_class</code>结构体。这就引出了<code class="highlighter-rouge">meta-class</code>的概念，元类中保存了创建类对象及类方法所需的所有信息。
任何<code class="highlighter-rouge">NSObject</code>继承体系下的<code class="highlighter-rouge">meta-class</code>都使用<code class="highlighter-rouge">NSObject</code>的<code class="highlighter-rouge">meta-class</code>作为自己的所属类，而基类的<code class="highlighter-rouge">meta-class</code>的<code class="highlighter-rouge">isa</code>指针指向它自己。</p>

<h4 id="methodobjc_method">Method(Objc_method)</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct objc_method *Method;

struct objc_method {
    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;
    char * _Nullable method_types                            OBJC2_UNAVAILABLE;
    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;
}                                                            
</code></pre></div></div>

<p><code class="highlighter-rouge">Method</code>和平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码。
<code class="highlighter-rouge">objc_method</code>结构体内容：</p>
<ul>
  <li><code class="highlighter-rouge">SEL _Nonnull method_name</code> 方法名</li>
  <li><code class="highlighter-rouge">char * _Nullable method_types</code> 方法类型</li>
  <li><code class="highlighter-rouge">IMP _Nonnull method_imp</code> 方法实现</li>
</ul>

<p>从此看出，<code class="highlighter-rouge">SEL</code>和<code class="highlighter-rouge">IMP</code>均是<code class="highlighter-rouge">Method</code>的属性。</p>

<h4 id="selobjc_selector">SEL(objc_selector)</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct objc_selector *SEL;
</code></pre></div></div>

<p><code class="highlighter-rouge">objc_msgSend</code>函数第二个参数类型是<code class="highlighter-rouge">SEL</code>，它是<code class="highlighter-rouge">selector</code>在<code class="highlighter-rouge">Objective-C</code>中的表示类型（<code class="highlighter-rouge">Swift</code>中是<code class="highlighter-rouge">Selector</code>类）。<code class="highlighter-rouge">selector</code>是方法选择器，可以理解区分方法的<code class="highlighter-rouge">ID</code>，而这个<code class="highlighter-rouge">ID</code>的数据结构是<code class="highlighter-rouge">SEL</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@property SEL selector;
</code></pre></div></div>

<p>可以看出来<code class="highlighter-rouge">selector</code>是<code class="highlighter-rouge">SEL</code>的一个实例。
其实<code class="highlighter-rouge">selector</code>就是个映射到方法的<code class="highlighter-rouge">C</code>字符串，你可以用<code class="highlighter-rouge">Objective-C</code>编译器命令<code class="highlighter-rouge">@selector()</code>或者<code class="highlighter-rouge">Runtime</code>系统的<code class="highlighter-rouge">sel_registerName</code>函数来获取一个<code class="highlighter-rouge">SEL</code>类型的方法选择器。</p>

<p><code class="highlighter-rouge">selector</code>既然是一个<code class="highlighter-rouge">string</code>，应该是类似<code class="highlighter-rouge">className+method</code>的组合，命名规则有两条：</p>

<ul>
  <li>同一个类，<code class="highlighter-rouge">selector</code>不能重复</li>
  <li>不同的类，<code class="highlighter-rouge">selector</code>可以重复</li>
</ul>

<p>这样会有一个弊端，我们在写<code class="highlighter-rouge">C</code>代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在<code class="highlighter-rouge">Objective-C</code>中是行不通的，因为<code class="highlighter-rouge">selector</code>只记了<code class="highlighter-rouge">className+method</code>，没有参数，所以没法取费不同的<code class="highlighter-rouge">method</code>。</p>

<p>比如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)caculate(NSInteger)num;
- (void)caculate(CGFloat)num;
</code></pre></div></div>

<p>这样是会报错的。</p>

<p>我们只能通过命名来区分：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)caculateWithInt(NSInteger)num;
- (void)caculateWithFloat(CGFloat)num;
</code></pre></div></div>

<p>在不同类中相同名字的方法所对应的选择器是相同的，即使方法名字相同而变量类型不同也会导致他们具有相同的方法选择器。</p>

<h4 id="imp">IMP</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); 
</code></pre></div></div>

<p>就是指向最终实现程序的内存地址的指针。</p>

<p>在<code class="highlighter-rouge">iOS</code>的<code class="highlighter-rouge">Runtime</code>中，<code class="highlighter-rouge">Method</code>通过<code class="highlighter-rouge">selector</code>和<code class="highlighter-rouge">IMP</code>两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。</p>

<h4 id="类缓存objc_cache">类缓存(objc_cache)</h4>

<p>当<code class="highlighter-rouge">Objective-C</code>运行时通过跟踪它的<code class="highlighter-rouge">isa</code>指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当<code class="highlighter-rouge">objc_msgSend</code>查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。</p>

<p>为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的<code class="highlighter-rouge">objc_cache</code>，所以在实际运行中，大部分常用的方法都是会被缓存起来的，<code class="highlighter-rouge">Runtime</code>系统实际上非常快，接近直接执行内存地址的程序速度。</p>

<h4 id="categoryobjc_category">Category(objc_category)</h4>

<p><code class="highlighter-rouge">Category</code>是表示一个指向分类的结构体的指针，其定义如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct category_t { 
    const char *name; 
    classref_t cls; 
    struct method_list_t *instanceMethods; 
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
};

name：是指 class_name 而不是 category_name。
cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。
instanceMethods：category中所有给类添加的实例方法的列表。
classMethods：category中所有添加的类方法的列表。
protocols：category实现的所有协议的列表。
instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。
</code></pre></div></div>

<p>从上面的<code class="highlighter-rouge">objc_category</code>的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。</p>

<h3 id="runtime消息转发">Runtime消息转发</h3>

<p>上文中介绍了进行一次消息发送会在相关类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索直到继承树的根部(通常为<code class="highlighter-rouge">NSObject</code>)，如果还是找不到会怎么样呢？接下来会逐一介绍消息转发的流程，先看下图：</p>

<p><img src="https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/runtime-forward.png" alt="runtime-forward" /></p>

<p>消息转发三个步骤：动态方法解析；备用接收者；完整消息转发。</p>

<h4 id="动态方法解析">动态方法解析</h4>

<p>首先，<code class="highlighter-rouge">Objective-C</code>运行时会调用<code class="highlighter-rouge">+resolveInstanceMethod:</code>或者<code class="highlighter-rouge">+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回<code class="highlighter-rouge">Yes</code>，那运行时系统就会重新启动一次消息发送的过程。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (void)viewDidLoad {
    [super viewDidLoad];

    // 执行msg函数
    [self performSelector:@selector(msg:)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    // 检测到如果是执行msg函数，就动态解析，指定新的IMP
    if (sel == @selector(msg:)) {
        class_addMethod([self class], sel, (IMP)msgMethod, "v@:");
        return YES;
    }
    return [super resolveInstanceMethod:sel];
}

// 新的msg函数
void msgMethod(id obj, SEL _cmd) {
    NSLog(@"Doing msg");
}
</code></pre></div></div>

<p>打印日志：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2020-01-02 10:01:00.294697+0800 Runtime-Demo[44489:1441571] Doing msg
</code></pre></div></div>

<p>可以看到虽然没有实现<code class="highlighter-rouge">msg:</code>函数，但是我们通过<code class="highlighter-rouge">class_addMethod</code>动态添加<code class="highlighter-rouge">msgMethod</code>函数，并执行<code class="highlighter-rouge">msgMethod</code>这个函数的<code class="highlighter-rouge">IMP</code>。从打印日志看，成功实现了消息转发。</p>

<p>如果<code class="highlighter-rouge">+resolveInstanceMethod:</code>方法<code class="highlighter-rouge">NO</code>，运行时就会移到下一步<code class="highlighter-rouge">-forwardingTargetForSelector:</code>。</p>

<h4 id="备用接收者">备用接收者</h4>

<p>如果目标对象实现了<code class="highlighter-rouge">-forwardingTargetForSelector:</code>，<code class="highlighter-rouge">Runtime</code>这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "ViewController.h"
#import &lt;objc/runtime.h&gt;

@interface Receiver: NSObject

@end

@implementation Receiver

// Receiver的msg函数
- (void)msg {
    NSLog(@"Doing msg");
}

@end

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    // 执行msg函数
    [self performSelector:@selector(msg)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return NO; //返回NO，进入下一步转发
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    if (aSelector == @selector(msg)) {
        return [Receiver new]; //返回Receiver对象，让Receiver对象接收这个消息
    }
    return [super forwardingTargetForSelector:aSelector];
}

@end
</code></pre></div></div>

<p>打印日志：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2020-01-02 10:16:20.360133+0800 Runtime-Demo[44635:1453911] Doing msg
</code></pre></div></div>

<p>可以看到我们通过<code class="highlighter-rouge">-forwardingTargetForSelector:</code>把当前<code class="highlighter-rouge">ViewController</code>的方法转发给了<code class="highlighter-rouge">Receiver</code>去执行了。打印结果也证明我们成功实现了转发。</p>

<h4 id="完整消息转发">完整消息转发</h4>

<p>如果以上两步还不能处理未知消息，则唯一能做的就是启动完整的消息转发机制了。首先它会发送<code class="highlighter-rouge">methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code class="highlighter-rouge">methodSignatureForSelector:</code>返回<code class="highlighter-rouge">nil</code>，运行时系统则会发出<code class="highlighter-rouge">doesNotRecognizeSelector:</code>消息，程序也就挂掉了。如果返回了一个函数签名，运行时就会创建一个<code class="highlighter-rouge">NSInvocation</code>对象并发送<code class="highlighter-rouge">-forwardInvocation:</code>消息给目标对象。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import "ViewController.h"
#import &lt;objc/runtime.h&gt;

@interface Receiver: NSObject

@end

@implementation Receiver

// Receiver的msg函数
- (void)msg {
    NSLog(@"Doing msg");
}

@end

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    // 执行msg函数
    [self performSelector:@selector(msg)];
}

+ (BOOL)resolveInstanceMethod:(SEL)sel {
    return NO; //返回NO，进入下一步转发
}

- (id)forwardingTargetForSelector:(SEL)aSelector {
    return nil;//返回nil，进入下一步转发
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
    if ([NSStringFromSelector(aSelector) isEqualToString:@"msg"]) {
    		//签名，进入forwardInvocation
        return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    }
    
    return [super methodSignatureForSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    SEL sel = anInvocation.selector;
    
    Receiver *receiver = [Receiver new];
    if([receiver respondsToSelector:sel]) {
        [anInvocation invokeWithTarget:receiver];
    }
    else {
        [self doesNotRecognizeSelector:sel];
    }
}

@end
</code></pre></div></div>

<p>打印日志：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

:ET