I"<p>本人也看着众大神的文章才对runloop有了一定的了解，希望通过这篇文章来记录并加深对runloop的理解。<a href="https://opensource.apple.com/tarballs/CF/">CFRunloop源代码</a></p>

<h3 id="一runloop简介">一、RunLoop简介</h3>

<p>RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>

<p>OSX/iOS 系统中，提供了两个这样的对象：<code class="highlighter-rouge">NSRunLoop</code> 和 <code class="highlighter-rouge">CFRunLoopRef</code>。</p>

<ul>
  <li><code class="highlighter-rouge">CFRunLoopRef</code> 是在 <code class="highlighter-rouge">CoreFoundation</code> 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</li>
  <li><code class="highlighter-rouge">NSRunLoop</code> 是基于 <code class="highlighter-rouge">CFRunLoopRef</code> 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</li>
</ul>

<h3 id="二runloop与线程关系">二、RunLoop与线程关系</h3>

<p>RunLoop 和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够不断地处理任务，并不退出。所以，我们就有了 RunLoop。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<code class="highlighter-rouge">CFRunLoopGetMain()</code> 和 <code class="highlighter-rouge">CFRunLoopGetCurrent()</code>。 这两个函数源码为下面这样:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef __CFRunLoops = NULL;
// 访问 __CFRunLoops 时的锁
static CFSpinLock_t loopsLock = CFSpinLockInit;

CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {
    if (pthread_equal(t, kNilPthreadT)) {
				t = pthread_main_thread_np();
    }
    __CFSpinLock(&amp;loopsLock);
    if (!__CFRunLoops) {
    		// 第一次进入时，初始化全局 __CFRunLoops，并先为主线程创建一个 RunLoop
        __CFSpinUnlock(&amp;loopsLock);
				CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);
				CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());
				CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) {
            CFRelease(dict);
        }
				CFRelease(mainLoop);
        __CFSpinLock(&amp;loopsLock);
    }
    // 直接从 __CFRunLoops 里获取
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    __CFSpinUnlock(&amp;loopsLock);
    if (!loop) {
    		// 获取不到时，创建一个
				CFRunLoopRef newLoop = __CFRunLoopCreate(t);
        __CFSpinLock(&amp;loopsLock);
				loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
				if (!loop) {
	    			CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);
	    			loop = newLoop;
				}
   			 __CFSpinUnlock(&amp;loopsLock);
				CFRelease(newLoop);
    }
    if (pthread_equal(t, pthread_self())) {
       	_CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);
        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {
            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (* (void *))__CFFinalizeRunLoop);
        }
    }
    return loop;
}
</code></pre></div></div>

<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>

:ET