I")`<p>Block 是开发过程中常用便捷的回调方式，那么block底层是怎么实现的呢？为什么会造成循环引用？下面将会解答上述问题。</p>

<h3 id="一block源码">一、Block源码</h3>

<p>先看一个简单的Block调用</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main(){
    int age = 0;
    void (^block)(void) = ^{
        NSLog(@"age is %d", age);
    };
    block();
    return 0;
}
</code></pre></div></div>

<p>将Objective-C代码转换为C\C++代码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 在终端输入一下命令
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m
</code></pre></div></div>

<p>查看main.cpp源码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct __block_impl {
  void *isa;      //isa指针，所以说Block是对象
  int Flags;
  int Reserved;
  void *FuncPtr;  //函数指针
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int age;
  // 构造函数（类似于OC的init方法），返回结构体对象
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int age = __cself-&gt;age; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_sx_ygl_c8ln07jdwrz6w5rgbq8m0000gn_T_blcok_8142ea_mi_0, age);
}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

int main(){
    int age = 0;
    // 定义block
    void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));
    // 执行block
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
    return 0;
}
</code></pre></div></div>

<p>从以上源码可看出：</p>

<ul>
  <li>Block内部有个isa指针，所以它本质上也是一个OC对象。</li>
  <li>Block是封装了函数调用以及函数调用环境的OC对象。</li>
  <li>Block是封装函数及其上下文的OC对象。</li>
</ul>

<h3 id="二block捕获变量">二、Block捕获变量</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.m
int global = 30;

int main(){
    auto int age = 10;
    static int num = 20;
    void (^block)(void) = ^{
        NSLog(@"age is %d, num is %d, global is %d", age, num, global);
    };
    age = 15;
    num = 25;
    global = 35;
    block();
    return 0;
}

输出日志：
age is 10, num is 25, global is 35
</code></pre></div></div>

<p>main.cpp的源码:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int global = 30;

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int age = __cself-&gt;age; // bound by copy
  int *num = __cself-&gt;num; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_sx_ygl_c8ln07jdwrz6w5rgbq8m0000gn_T_main_76bced_mi_0, age, (*num), global);
    }

int main() {
    auto int age = 10;
    static int num = 20;
    void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;num));
    age = 15;
    num = 25;
    global = 35;
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
    return 0;
}
</code></pre></div></div>

<p>原因：<strong>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制；auto变量age的block访问方式是值传递，static变量num的block访问方式是指针传递，block不需要对全局变量捕获，都是直接采用取全局变量的值</strong>。</p>

<p>Block里访问self是否会捕获？
<strong>会，self是当调用block函数的参数，参数是局部变量，self指向调用者；</strong></p>

<p>Block里访问成员变量是否会捕获？
**会，成员变量的访问其实是<code class="highlighter-rouge">self-&gt;xx</code>，先捕获self，再通过self访问里面的成员变量 **</p>

<h3 id="三block类型">三、Block类型</h3>

<h4 id="31-三种block类型">3.1 三种Block类型</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
    void (^global_block)(void) = ^{
        NSLog(@"global_block");
    };
    NSLog(@"global_block: %@ -&gt; %@ -&gt; %@ -&gt; %@",[global_block class], [[global_block class] superclass], [[[global_block class] superclass] superclass], [[[[[global_block class] superclass] superclass] superclass] superclass]);
    
    __block int age = 1;
    void (^stack_block)(void) = ^{
        NSLog(@"stack_block %d", age++);
    };
    NSLog(@"stack_block: %@ -&gt; %@ -&gt; %@ -&gt; %@",[stack_block class], [[stack_block class] superclass], [[[stack_block class] superclass] superclass], [[[[[stack_block class] superclass] superclass] superclass] superclass]);

    void (^malloc_block)(void) = [stack_block copy];
    NSLog(@"malloc_block: %@ -&gt; %@ -&gt; %@ -&gt; %@",[malloc_block class], [[malloc_block class] superclass], [[[malloc_block class] superclass] superclass], [[[[[malloc_block class] superclass] superclass] superclass] superclass]);
}

MRC输出日志：
global_block: __NSGlobalBlock__ -&gt; __NSGlobalBlock -&gt; NSBlock -&gt; (null)
stack_block: __NSStackBlock__ -&gt; __NSStackBlock -&gt; NSBlock -&gt; (null)
malloc_block: __NSMallocBlock__ -&gt; __NSMallocBlock -&gt; NSBlock -&gt; (null)

ARC输出日志：
global_block: __NSGlobalBlock__ -&gt; __NSGlobalBlock -&gt; NSBlock -&gt; (null)
stack_block: __NSMallocBlock__ -&gt; __NSMallocBlock -&gt; NSBlock -&gt; (null)
malloc_block: __NSMallocBlock__ -&gt; __NSMallocBlock -&gt; NSBlock -&gt; (null)

在ARC下，编译器做了很多的优化，往往看不到本质，上面的代码输出结果找不到__NSStackBlock__，因为编译器对__NSStackBlock__自动进行了copy操作。
改为MRC方法： Build Settings 里面的Automatic Reference Counting改为NO。
</code></pre></div></div>

<p>Block的类型，取决于isa指针，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>

<ul>
  <li><code class="highlighter-rouge">__NSGlobalBlock __ （ _NSConcreteGlobalBlock ）</code></li>
  <li><code class="highlighter-rouge">__NSStackBlock __ （ _NSConcreteStackBlock ）</code></li>
  <li><code class="highlighter-rouge">__NSMallocBlock __ （ _NSConcreteMallocBlock ）</code></li>
</ul>

<p>其中三种不同的类型和环境对应如下</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">block类型</th>
      <th style="text-align: center">环境</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">__NSGlobalBlock__</code></td>
      <td style="text-align: center">没有访问auto变量</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">__NSStackBlock__</code></td>
      <td style="text-align: center">访问了auto变量</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">__NSMallocBlock__</code></td>
      <td style="text-align: center"><code class="highlighter-rouge">__NSStackBlock__</code>调用了copy</td>
    </tr>
  </tbody>
</table>

<p>其在内存中的分配如下对应：</p>

<p><img src="https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/block-memory.png" alt="block-memory" /></p>

<h4 id="32-对每种类型block调用copy操作">3.2 对每种类型block调用copy操作</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
    void (^global_block_copy)(void) = [^{
        NSLog(@"global_block_copy");
    } copy];
    NSLog(@"global_block_copy: %@ -&gt; %lu",[global_block_copy class], (unsigned long)[global_block_copy retainCount]);
    
    __block int age = 1;
    void (^stack_block_copy)(void) = [^{
        NSLog(@"stack_block_copy: %d", age++);
    } copy];
    NSLog(@"stack_block_copy: %@ -&gt; %lu",[stack_block_copy class], (unsigned long)[stack_block_copy retainCount]);

    void (^malloc_block_copy)(void) = [stack_block_copy copy];
    NSLog(@"malloc_block_copy: %@ -&gt; %lu",[malloc_block_copy class], (unsigned long)[malloc_block_copy retainCount]);
}

输出日志：
global_block_copy: __NSGlobalBlock__
stack_block_copy: __NSMallocBlock__
malloc_block_copy: __NSMallocBlock__
</code></pre></div></div>

<p>总结：</p>

<ul>
  <li><code class="highlighter-rouge">__NSGlobalBlock__</code> 调用copy操作后，什么也不做</li>
  <li><code class="highlighter-rouge">__NSStackBlock __</code> 调用copy操作后，复制效果是：从栈复制到堆；副本存储位置是<strong>堆</strong></li>
  <li><code class="highlighter-rouge">__NSMallocBlock__</code> 调用copy操作后，复制效果是：引用计数增加；副本存储位置是<strong>堆</strong></li>
</ul>

<h4 id="33-block属性的建议写法">3.3 Block属性的建议写法</h4>

<p>MRC:</p>

<ul>
  <li><code class="highlighter-rouge">@property (copy, nonatomic) void (^block)(void);</code></li>
</ul>

<p>ARC:</p>

<ul>
  <li><code class="highlighter-rouge">@property (strong, nonatomic) void (^block)(void);</code></li>
  <li><code class="highlighter-rouge">@property (copy, nonatomic) void (^block)(void);</code></li>
</ul>

<h3 id="四对象类型的auto变量">四、对象类型的auto变量</h3>

<h4 id="41-block代码块包含对象类型变量时">4.1 Block代码块包含对象类型变量时</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// LMPerson.h
@property (nonatomic, assign) int age;

// LMPerson.m
- (void)dealloc {
    NSLog(@"%s",__func__);
}

// mian.m
typedef void(^LMBlock)(void);

typedef void(^LMBlock)(void);

int main() {
    LMBlock block;
    {
        LMPerson *person = [[LMPerson alloc]init];
        person.age = 10;
        
        block = ^{
            NSLog(@"---------%d", person.age);
        };
        NSLog(@"block.class = %@",[block class]);
        // MRC下，需要手动释放
        // [person release];
    }
    // MRC下，需要手动释放
    // [block release];
    NSLog(@"block销毁");
    return 0;
}

ARC输出日志：
block.class = __NSMallocBlock__ 
block销毁
-[LMPerson dealloc]

MRC输出日志
block.class = __NSStackBlock__
-[LMPerson dealloc]
block销毁
</code></pre></div></div>

<p>main.cpp源码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  LMPerson *person;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, LMPerson *_person, int flags=0) : person(_person) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre></div></div>

<p>ARC下block为堆block，block里面有一个person指针，person指针指向<code class="highlighter-rouge">LMPerson</code>对象。只要block还在，person就还在。block强引用了<code class="highlighter-rouge">LMPerson</code>对象。</p>

<p>MRC下还没有执行<code class="highlighter-rouge">NSLog(@"block销毁");</code>的时候，<code class="highlighter-rouge">[LMPerson dealloc]</code>已经执行了。也就是说，person离开大括号，就销毁了。</p>

<h4 id="_weak修饰">_weak修饰</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__weak LMPerson *weakPerson = person;
block = ^{
	NSLog(@"---------%d", weakPerson.age);
};

输出日志：
block.class = __NSStackBlock__
-[LMPerson dealloc]
block销毁
</code></pre></div></div>

<p>main.cpp源码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// cannot create __weak reference because the current deployment target does not support weak references 报错时使用一下命令
// xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  LMPerson *__weak weakPerson;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, LMPerson *__weak _weakPerson, int flags=0) : weakPerson(_weakPerson) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  // copy函数
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  // dispose函数
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

//copy函数内部会调用_Block_object_assign函数
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;weakPerson, (void*)src-&gt;weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);}

// dispose函数内部会调用_Block_object_dispose函数
static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;weakPerson, 3/*BLOCK_FIELD_IS_OBJECT*/);}
</code></pre></div></div>

<p>总结：</p>

<ul>
  <li>当block为<code class="highlighter-rouge">__NSStackBlock__</code>类型时候，是在栈空间，无论对外面使用的是strong 还是weak 都不会对外面的对象进行强引用</li>
  <li>当block为<code class="highlighter-rouge">__NSMallocBlock__</code>类型时候，是在堆空间，block是内部的<code class="highlighter-rouge">_Block_object_assign</code>函数会根据<code class="highlighter-rouge">strong</code>或者 <code class="highlighter-rouge">weak</code>对外界的对象进行强引用或者弱引用。</li>
  <li>当block内部访问了对象类型的auto变量时，如果block是在栈上，将不会对auto变量产生强引用</li>
  <li>
    <p>当block内部访问了对象类型的auto变量时，如果block被拷贝到堆上，会调用block内部的copy函数，copy函数内部会调用<code class="highlighter-rouge">_Block_object_assign</code>函数，<code class="highlighter-rouge">_Block_object_assign</code>函数会根据auto变量的修饰符<code class="highlighter-rouge">（__strong、__weak、__unsafe_unretained）</code>做出相应的操作，形成强引用（retain）或者弱引用。</p>
  </li>
  <li>如果block从堆上移除，会调用block内部的dispose函数，dispose函数内部会调用<code class="highlighter-rouge">_Block_object_dispose</code>函数,<code class="highlighter-rouge">_Block_object_dispose</code>函数会自动释放引用的auto变量（release）。</li>
</ul>

<p><em>如果block在<code class="highlighter-rouge">栈</code>空间，不管外部变量是强引用还是弱引用，block都会弱引用访问对象</em></p>

<p><em>如果block在<code class="highlighter-rouge">堆</code>空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用</em></p>

<h3 id="五block修改局部变量">五、Block修改局部变量</h3>

<h4 id="51-全局变量">5.1 全局变量</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int age = 10;

int main() {
    void (^block)(void) = ^{
        age = 30;
        NSLog(@"age is %d", age);
    };
    block();
    return 0;
}
// 输出日志： age is 30

// main.cpp
int age = 10;

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
        age = 30;
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_sx_ygl_c8ln07jdwrz6w5rgbq8m0000gn_T_main_ec26a1_mi_0, age);
    }

int main() {
    void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
    return 0;
}
</code></pre></div></div>

<p>全局变量，是所有地方都可访问的，在block内部可以直接访问并修改全局变量age。</p>

<h4 id="52-static修饰局部变量">5.2 static修饰局部变量</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
    static int age = 10;
    void (^block)(void) = ^{
        age = 30;
        NSLog(@"age is %d", age);
    };
    block();
    return 0;
}
// 输出日志： age is 30

// main.cpp
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int *age;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_age, int flags=0) : age(_age) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  int *age = __cself-&gt;age; // bound by copy
        (*age) = 30;
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_sx_ygl_c8ln07jdwrz6w5rgbq8m0000gn_T_main_06dc00_mi_0, (*age));
    }

int main() {
    static int age = 10;
    void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;age));
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
    return 0;
}
</code></pre></div></div>

<p>当局部变量用static修饰之后，这个block内部会有个成员是<code class="highlighter-rouge">int *age</code>，也就是说把age的地址捕获了。这样的话，当然在block内部可以修改局部变量age。</p>

<h4 id="__block来修饰">__block来修饰</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
    __block int age = 10;
    void (^block)(void) = ^{
        age = 30;
        NSLog(@"age is %d", age);
    };
    block();
    return 0;
}

// 输出日志： age is 30

// main.cpp
struct __Block_byref_age_0 {
  void *__isa;
__Block_byref_age_0 *__forwarding; // 指向自身的指针
 int __flags;
 int __size;
 int age; // 使用值
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_age_0 *age; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref
        // __forwarding指向的结构体的age改为30，也就是__Block_byref_age_0结构体age本身的age的值修改为30
        (age-&gt;__forwarding-&gt;age) = 30;
        // 通过__forwarding找到指针，然后去取出age值。
        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_sx_ygl_c8ln07jdwrz6w5rgbq8m0000gn_T_main_5da7ea_mi_0, (age-&gt;__forwarding-&gt;age));
    }

int main() {
    // __Block_byref_age_0 结构体初始化，传入&amp;age赋值指向s自身的指针__forwarding，30赋值__Block_byref_age_0结构体的age
    __attribute__((__blocks__(byref))) __Block_byref_age_0 age = {(void*)0,(__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10};
    void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_age_0 *)&amp;age, 570425344));
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
    return 0;
}
</code></pre></div></div>

<p>调用的是，从<code class="highlighter-rouge">__Block_byref_age_0</code>的指针找到 <code class="highlighter-rouge">age</code>所在的内存，然后修改值</p>

<p><img src="https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/block-__block.png" alt="block-__block" /></p>

<p><code class="highlighter-rouge">__block</code>可以用于解决block内部无法修改auto变量值的问题，<code class="highlighter-rouge">__block</code>不能修饰全局变量、静态变量（static），并且编译器会将<code class="highlighter-rouge">__block</code>修饰的变量包装成一个对象。</p>

<h3 id="六block内存管理">六、Block内存管理</h3>

<h4 id="61-block访问oc对象">6.1 block访问OC对象</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
    LMPerson *person = [[LMPerson alloc] init];
    void (^block)(void) = ^{
        NSLog(@"person %@", person);
    };
    block();
    return 0;
}
</code></pre></div></div>

<p>main.cpp ARC源码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  LMPerson *person;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, LMPerson *_person, int flags=0) : person(_person) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  LMPerson *person = __cself-&gt;person; // bound by copy

        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_sx_ygl_c8ln07jdwrz6w5rgbq8m0000gn_T_main_2d147f_mi_0, person);
    }
    
// block的copy时会调用 __main_block_copy_0
// _Block_object_assign函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);}

// block从堆中移除时调用__main_block_dispose_0
// _Block_object_dispose函数会自动释放指向的对象（release）
static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;person, 3/*BLOCK_FIELD_IS_OBJECT*/);}

// 因为是在ARC下，所以会copy，栈上拷贝到堆上，结构体__main_block_desc_0`中有copy`和`dispose`
static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

int main() {
    LMPerson *person = ((LMPerson *(*)(id, SEL))(void *)objc_msgSend)((id)((LMPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("LMPerson"), sel_registerName("alloc")), sel_registerName("init"));
    void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, person, 570425344));
    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);
    return 0;
}
</code></pre></div></div>

<p>由前文及以上可知：</p>

<ul>
  <li>
    <p>当block在栈上时，并不会对__block变量产生强引用</p>
  </li>
  <li>
    <p>当block被copy到堆时，会调用block内部的copy函数，copy函数内部会调用<code class="highlighter-rouge">_Block_object_assign</code>函数，<code class="highlighter-rouge">_Block_object_assign</code>函数会对<code class="highlighter-rouge">__block</code>变量形成强引用（retain）</p>
  </li>
  <li>
    <p>当block从堆中移除时，会调用block内部的dispose函数，dispose函数内部会调用<code class="highlighter-rouge">_Block_object_dispose</code>函数,<code class="highlighter-rouge">_Block_object_dispose</code>函数会自动释放引用的auto变量（release）</p>
  </li>
</ul>

<h4 id="62循环引用">6.2、循环引用</h4>

<p>看如下代码，有个LMPerson类，里面两个属性，分别是block和age</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// LMPerson.h
@property (nonatomic, assign) int age;
@property (nonatomic, copy) void(^block)(void);

// LMPerson.m
- (void)dealloc {
    NSLog(@"%s",__func__);
}

//main.m
</code></pre></div></div>

:ET