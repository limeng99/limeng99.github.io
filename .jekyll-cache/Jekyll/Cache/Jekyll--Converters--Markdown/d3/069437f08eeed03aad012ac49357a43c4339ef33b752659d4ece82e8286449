I"õ<p>æœ¬äººä¹Ÿçœ‹ç€ä¼—å¤§ç¥çš„æ–‡ç« æ‰å¯¹runloopæœ‰äº†ä¸€å®šçš„äº†è§£ï¼Œå¸Œæœ›é€šè¿‡è¿™ç¯‡æ–‡ç« æ¥è®°å½•å¹¶åŠ æ·±å¯¹runloopçš„ç†è§£ã€‚<a href="https://opensource.apple.com/tarballs/CF/">CFRunloopæºä»£ç </a></p>

<h3 id="ä¸€runloopç®€ä»‹">ä¸€ã€RunLoopç®€ä»‹</h3>

<p>RunLoop å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡ç®¡ç†äº†å…¶éœ€è¦å¤„ç†çš„äº‹ä»¶å’Œæ¶ˆæ¯ï¼Œå¹¶æä¾›äº†ä¸€ä¸ªå…¥å£å‡½æ•°æ¥æ‰§è¡Œä¸Šé¢ Event Loop çš„é€»è¾‘ã€‚çº¿ç¨‹æ‰§è¡Œäº†è¿™ä¸ªå‡½æ•°åï¼Œå°±ä¼šä¸€ç›´å¤„äºè¿™ä¸ªå‡½æ•°å†…éƒ¨ â€œæ¥å—æ¶ˆæ¯-&gt;ç­‰å¾…-&gt;å¤„ç†â€ çš„å¾ªç¯ä¸­ï¼Œç›´åˆ°è¿™ä¸ªå¾ªç¯ç»“æŸï¼ˆæ¯”å¦‚ä¼ å…¥ quit çš„æ¶ˆæ¯ï¼‰ï¼Œå‡½æ•°è¿”å›ã€‚</p>

<p>OSX/iOS ç³»ç»Ÿä¸­ï¼Œæä¾›äº†ä¸¤ä¸ªè¿™æ ·çš„å¯¹è±¡ï¼š<code class="highlighter-rouge">NSRunLoop</code> å’Œ <code class="highlighter-rouge">CFRunLoopRef</code>ã€‚</p>

<ul>
  <li><code class="highlighter-rouge">CFRunLoopRef</code> æ˜¯åœ¨ <code class="highlighter-rouge">CoreFoundation</code> æ¡†æ¶å†…çš„ï¼Œå®ƒæä¾›äº†çº¯ C å‡½æ•°çš„ APIï¼Œæ‰€æœ‰è¿™äº› API éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</li>
  <li><code class="highlighter-rouge">NSRunLoop</code> æ˜¯åŸºäº <code class="highlighter-rouge">CFRunLoopRef</code> çš„å°è£…ï¼Œæä¾›äº†é¢å‘å¯¹è±¡çš„ APIï¼Œä½†æ˜¯è¿™äº› API ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</li>
</ul>

<h3 id="äºŒrunloopä¸çº¿ç¨‹å…³ç³»">äºŒã€RunLoopä¸çº¿ç¨‹å…³ç³»</h3>

<p>RunLoop å’Œçº¿ç¨‹æ˜¯æ¯æ¯ç›¸å…³çš„ï¼Œæˆ‘ä»¬çŸ¥é“çº¿ç¨‹çš„ä½œç”¨æ˜¯ç”¨æ¥æ‰§è¡Œç‰¹å®šçš„ä¸€ä¸ªæˆ–å¤šä¸ªä»»åŠ¡ï¼Œåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œçº¿ç¨‹æ‰§è¡Œå®Œä¹‹åå°±ä¼šé€€å‡ºï¼Œå°±ä¸èƒ½å†æ‰§è¡Œä»»åŠ¡äº†ã€‚è¿™æ—¶æˆ‘ä»¬å°±éœ€è¦é‡‡ç”¨ä¸€ç§æ–¹å¼æ¥è®©çº¿ç¨‹èƒ½å¤Ÿä¸æ–­åœ°å¤„ç†ä»»åŠ¡ï¼Œå¹¶ä¸é€€å‡ºã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å°±æœ‰äº† RunLoopã€‚</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å…¨å±€çš„Dictionaryï¼Œkey æ˜¯ pthread_tï¼Œ value æ˜¯ CFRunLoopRef
static CFMutableDictionaryRef __CFRunLoops = NULL;
static CFSpinLock_t loopsLock = CFSpinLockInit;

CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {
    if (pthread_equal(t, kNilPthreadT)) {
				t = pthread_main_thread_np();
    }
    __CFSpinLock(&amp;loopsLock);
    if (!__CFRunLoops) {
        __CFSpinUnlock(&amp;loopsLock);
				CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);
				CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());
				CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) {
            CFRelease(dict);
        }
				CFRelease(mainLoop);
        __CFSpinLock(&amp;loopsLock);
    }
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    __CFSpinUnlock(&amp;loopsLock);
    if (!loop) {
	CFRunLoopRef newLoop = __CFRunLoopCreate(t);
        __CFSpinLock(&amp;loopsLock);
	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
	if (!loop) {
	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);
	    loop = newLoop;
	}
        // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it
        __CFSpinUnlock(&amp;loopsLock);
	CFRelease(newLoop);
    }
    if (pthread_equal(t, pthread_self())) {
        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);
        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {
            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);
        }
    }
    return loop;
}
</code></pre></div></div>

:ET