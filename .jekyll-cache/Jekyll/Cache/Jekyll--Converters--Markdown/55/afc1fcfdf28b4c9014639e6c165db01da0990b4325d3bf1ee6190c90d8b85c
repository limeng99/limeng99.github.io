I"!<p>当用户点击了App图标，到能够看到App主界面内容为止，在这个过程中应用做了那些事情呢？这些事情是否可以优化从而提高启动速度呢？下面我们将会讨论以上问题。</p>

<h3 id="main之前">main()之前</h3>

<p>在调用<code class="highlighter-rouge">main()</code>函数之前，基本所有工作都是由操作系统完成的，开发者能够插手的地方不多，多以如果想要想要优化这段时间，就必须了解，操作系统在<code class="highlighter-rouge">main()</code>之前做了什么。</p>

<p><code class="highlighter-rouge">main()</code>之前操作系统所做的工作是把可执行文件（Mach-O格式）加载到内存空间，然后动态链接库dyld，再执行一系列动态链接操作和初始化操作的过程（加载、绑定。及初始化）。</p>

<h4 id="加载过程从exec到main">加载过程—从exec()到main()</h4>

<p><img src="https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/main-load.png" alt="main-load" /></p>

<ul>
  <li><code class="highlighter-rouge">exec()</code>是一个系统调用</li>
  <li>App对应的可执行文件加载到内存</li>
  <li>把<code class="highlighter-rouge">Dyld</code>加载到内存中，<code class="highlighter-rouge">Dyld：the dynamic link editor</code>所有动态链接库和我们App的静态库.a和所有类文件编译后.o文件，最终都由dyld加载到内存的.</li>
  <li><code class="highlighter-rouge">Dyld</code>从主执行文件的<code class="highlighter-rouge">header</code>获取到需要加载的所依赖动态库列表，然后它需要找到每个<code class="highlighter-rouge">dylib</code>，而用所依赖的<code class="highlighter-rouge">dylib</code>文件可能会再依赖其他<code class="highlighter-rouge">dylib</code>，所以所需要加载的是动态库列表的一个递归依赖集合</li>
  <li><code class="highlighter-rouge">Rebase</code>和<code class="highlighter-rouge">Bind</code>
    <ul>
      <li><code class="highlighter-rouge">Rebase</code>在<code class="highlighter-rouge">Image</code>内部调整指针的指向。在过去会把动态库加载到指定地址，所有指针和数据对于代码都是对的，而现在地址空间布局是随机化，所以需要在原来的地址根据随机的偏移量做一下修正</li>
      <li><code class="highlighter-rouge">Bind</code>是吧指针正确地指向<code class="highlighter-rouge">Image</code>外部的内容。这些指向外部的指针被符号(<code class="highlighter-rouge">symbol</code>)名称绑定，<code class="highlighter-rouge">Dyld</code>需要去符号表里查找，找到<code class="highlighter-rouge">symbol</code>对应的实现。</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">Objc</code></li>
  <li>
    <p>注册<code class="highlighter-rouge">Objc</code>类（class registration）</p>
  </li>
  <li>
    <p>把<code class="highlighter-rouge">category</code>的定义插入方法列表（category registration）</p>
  </li>
  <li>保证每一个<code class="highlighter-rouge">selector</code>唯一（selector uniquing）</li>
  <li><code class="highlighter-rouge">initializers</code>
    <ul>
      <li><code class="highlighter-rouge">Objc</code>的<code class="highlighter-rouge">+load()</code>函数</li>
      <li><code class="highlighter-rouge">C++</code>的构造函数属性函数</li>
      <li>非基本类型的<code class="highlighter-rouge">C++</code>静态全局变量的创建(通常是类或者结构体)</li>
    </ul>
  </li>
</ul>

<p>最后，<code class="highlighter-rouge">Dyld</code>会调用<code class="highlighter-rouge">mian()</code>函数，<code class="highlighter-rouge">mian()</code>会调用<code class="highlighter-rouge">UIApplicationMain()</code>。</p>

<h4 id="1加载dyld">1、加载Dyld</h4>

<p>了解完<code class="highlighter-rouge">main()</code>之前的加载过程后，我们可以分析出影响<code class="highlighter-rouge">main</code>调用前启动时间的因素：</p>

<ol>
  <li>
    <p>动态库加载越多，启动越慢</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Objc</code>类，方法越多，启动越慢</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Objc</code>的<code class="highlighter-rouge">+load()</code>越多，启动越慢</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">C</code>的<code class="highlighter-rouge">constructor</code>函数越多，启动越慢</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">C++</code>静态对象越多，启动越慢</p>
  </li>
</ol>

<h4 id="main加载前启动优化">main()加载前启动优化：</h4>

<ol>
  <li>减少依赖不必要的库，不管是动态库还是静态库；如果可以的话，把动态库改造成静态库； 如果必须依赖动态库，则把多个非系统的动态库合并成一个动态库；</li>
  <li>检查下 <code class="highlighter-rouge">framework</code>应当设为<code class="highlighter-rouge">optional</code>和<code class="highlighter-rouge">required</code>， 如果该<code class="highlighter-rouge">framework</code>在当前App支持的所有<code class="highlighter-rouge">iOS</code>系统版本都存在，那么就设为<code class="highlighter-rouge">required</code>，否则就设为<code class="highlighter-rouge">optional</code>， 因为<code class="highlighter-rouge">optional</code>会有些额外的检查；</li>
  <li>合并或者删减一些<code class="highlighter-rouge">OC</code>类和函数；</li>
  <li>删减一些无用的静态变量；</li>
  <li>删减没有被调用到或者已经废弃的方法；</li>
  <li>将不必须在<code class="highlighter-rouge">+load</code>方法中做的事情延迟到<code class="highlighter-rouge">+initialize</code>中，尽量不要用<code class="highlighter-rouge">C++</code>虚函数(创建虚函数表有开销) ；</li>
  <li>类和方法名不要太长：<code class="highlighter-rouge">iOS</code>每个类和方法名都在<code class="highlighter-rouge">__cstring</code>段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的； 因还是<code class="highlighter-rouge">Objective-C</code>的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，<code class="highlighter-rouge">Objective-C</code>对象模型会把类/方法名字符串都保存下来；</li>
  <li><code class="highlighter-rouge">dispatch_once()</code>代替所有的 <code class="highlighter-rouge">attribute((constructor))</code> 函数、<code class="highlighter-rouge">C++</code>静态对象初始化、<code class="highlighter-rouge">Objc</code>的<code class="highlighter-rouge">+load</code>函数；</li>
  <li>对图片进行可接受范围内的压缩；</li>
</ol>

<h3 id="main之后">main()之后</h3>

<p><code class="highlighter-rouge">main()</code>函数之后，即从<code class="highlighter-rouge">main()</code>开始，到<code class="highlighter-rouge">AppDelegate</code>的<code class="highlighter-rouge">didFinishLaunchingWithOptions</code>方法执行完毕，至App初始化完成，首页请求、首页渲染等过程后，用户看到界面为止。</p>

<p><code class="highlighter-rouge">main()</code>加载后启动优化：</p>

<ol>
  <li>减少启动初始化的流程，能懒加载的就懒加载，能放后台初始化的就放后台， 能够延时初始化的就延时，不要卡主线程的启动时间，已经下线的业务直接删掉；</li>
  <li>优化代码逻辑，去除一些非必要的逻辑和代码，减少每个流程所消耗的时间；</li>
  <li>启动阶段使用多线程来进行初始化，把<code class="highlighter-rouge">CPU</code>的性能尽量发挥出来；</li>
  <li>使用纯代码而不是<code class="highlighter-rouge">xib</code>或者<code class="highlighter-rouge">storyboard</code>来进行<code class="highlighter-rouge">UI</code>框架的搭建，尤其是主<code class="highlighter-rouge">UI</code>框架比如<code class="highlighter-rouge">TabBarController</code>这种， 尽量避免使用<code class="highlighter-rouge">xib</code>和<code class="highlighter-rouge">storyboard</code>，因为<code class="highlighter-rouge">xib</code>和<code class="highlighter-rouge">storyboard</code>也还是要解析成代码来渲染页面，多了一些步骤；</li>
</ol>

<h3 id="参考链接">参考链接</h3>

<p><a href="https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html">美团外卖iOS App冷启动治理</a></p>
:ET