I"<p>在性能优化中一个最具参考价值的属性是FPS:Frames Per Second，其实就是屏幕刷新率，苹果的iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，这每刷新一次就是一帧frame，FPS也就是每秒钟刷新多少帧画面。当页面在执行动画或者滑动的时候，FPS值的大小体现了页面的流畅程度高低，当低于45的时候卡顿会比较明显。</p>

<h3 id="一入门级">一、入门级</h3>

<h5 id="11-用arc管理内存">1.1 用ARC管理内存</h5>

<p>ARC (<code class="highlighter-rouge">Automatic Reference Counting</code>, 自动引用计数) 和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。忘掉代码段结尾的release简直像记得吃饭一样简单。而ARC会自动在底层为你做这些工作。除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。</p>

<h5 id="12-使用-reuseidentifier">1.2 使用 reuseIdentifier</h5>

<p>为了性能最优化，<code class="highlighter-rouge">UITableView</code>用<code class="highlighter-rouge">tableView:cellForRowAtIndexPath:</code>为rows分配cells的时候，它的数据应该重用<code class="highlighter-rouge">UITableViewCell</code>。一个<code class="highlighter-rouge">UITableView</code>维持一个队列的数据可重用的<code class="highlighter-rouge">UITableViewCell</code>对象。<code class="highlighter-rouge">UICollectionView</code>使用<code class="highlighter-rouge">UICollectionViewCell</code>同样使用reuseIdentifier。同<code class="highlighter-rouge">UICollectionView</code>及<code class="highlighter-rouge">UITableView</code>的组视图header和footer也需要使用reuseIdentifier进行重用处理，以提高性能；</p>

<h5 id="13-减少透明-view">1.3 减少透明 view</h5>

<p>使用透明view会引起Blending，在iOS的图形处理中，Blending主要指的是混合像素颜色的计算。最直观的例子就是，我们把两个图层叠加在一起，如果第一个图层的透明的，则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。</p>

<p>导致Blending的原因：<code class="highlighter-rouge">UIView</code>的alpha&lt;1；<code class="highlighter-rouge">UIImageView</code>的image含有alpha channel (即使<code class="highlighter-rouge">UIImageView</code>的alpha是1，但只要image含有透明通道，则仍会导致Blending)。</p>

<p>为什么Blending会导致性能的损失？
原因是很直观的，如果一个图层是不透明的，则系统直接显示该图层的颜色即可。而如果图层是透明的，则会引起更多的计算，因为需要把另一个的图层也包括进来，进行混合后的颜色计算。</p>

<p><code class="highlighter-rouge">UIView</code>的<code class="highlighter-rouge">opaque</code>属性设置为YES，减少性能消耗，因为GPU将不会做任何合成，而是简单从这个层拷贝。</p>

<h5 id="14-避免过于庞大的xib">1.4 避免过于庞大的XIB</h5>

<p>当加载一个 Xib 时，它所有的内容都会被加载，如果这个 Xib 中有的View 你不会马上用到，加载就是浪费资源。而加载 StoryBoard 时，并不会把所有的ViewController 都加载，只会按需加载。</p>

<h5 id="15-不要阻塞主线程">1.5 不要阻塞主线程</h5>

<p>永远不要使主线程承担过多。因为<code class="highlighter-rouge">UIKit</code>在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。主线程任务太多导致阻塞，将会使你的app会失去反应。</p>

<p>大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。如果你需要做耗费巨大资源的操作，尽量放入异步线程进行处理，不要在主线程进行操作。</p>

<h5 id="16--使用尺寸匹配的uiimage">1.6 . 使用尺寸匹配的UIImage</h5>

<p>如果要在<code class="highlighter-rouge">UIImageView</code>中显示一个来自bundle的图片，你应保证图片的大小和<code class="highlighter-rouge">UIImageView</code>的大小相同。在运行中缩放图片是很耗费资源的，特别是<code class="highlighter-rouge">UIImageView</code>嵌套在<code class="highlighter-rouge">UIScrollView</code>中的情况下。</p>

<p>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread缩放一次，然后在<code class="highlighter-rouge">UIImageView</code>中使用缩放后的图片。</p>

<h5 id="17-选择正确的collection">1.7 选择正确的Collection</h5>

<p>学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。</p>

<p>Apple的 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Collections.html">Collections Programming Topics</a> 文档详尽介绍了可用的collections间的差别和你该在哪些场景中使用它们。<code class="highlighter-rouge">NSSet</code>和<code class="highlighter-rouge">NSArray</code>都是对象容器，用于存储对象，属于集合；<code class="highlighter-rouge">NSSet </code>与 <code class="highlighter-rouge">NSMutableSet</code>是无序的集合，在内存中存储方式是不连续,<code class="highlighter-rouge">NSArray</code>是有序的集合，在内存中存储位置是连续的</p>

<p><code class="highlighter-rouge">NSArray / NSMutableArray</code></p>

<ul>
  <li>
    <p><code class="highlighter-rouge">containsObject; indexOfObject; removeObject</code>均会遍历元素查看是否匹配，复杂度等于或小于 O(n)</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">objectAtIndex；firstObject；lastObject; addObject; removeLastObject</code>这些只针对栈顶，栈底的操作时间复杂度都是 O(1)</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">indexOfObject:inSortedRange:options:usingComparator:</code>使用的是二分查找，时间复杂度是O(log n)</p>
  </li>
</ul>

<p><code class="highlighter-rouge">NSSet / NSMutableSet / NSCountedSet</code></p>

<ul>
  <li>
    <p>集合类型是无序并且没有重复元素的。这样可以使用hash table 进行快速的操作。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">addObject; removeObject; containsObject</code>都是时间复杂度按照 O(1) 来的。需要注意的是将数组转成Set 时，会将重复元素合并为一个，并且失去排序。</p>
  </li>
</ul>

<p><code class="highlighter-rouge">NSDictionary / NSMutableDictionary</code></p>

<ul>
  <li>和Set 一样都可以使用 hash table ，多了键值对应。添加和删除元素都是 O(1)。</li>
</ul>

<h5 id="18-打开gzip压缩">1.8 打开gzip压缩。</h5>

<p>app可能大量依赖于服务器资源，问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。</p>

:ET