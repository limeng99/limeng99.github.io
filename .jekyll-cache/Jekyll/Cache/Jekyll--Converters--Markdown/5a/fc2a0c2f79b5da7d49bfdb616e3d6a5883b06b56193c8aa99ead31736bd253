I"©z<p>æœ¬äººä¹Ÿçœ‹ç€ä¼—å¤§ç¥çš„æ–‡ç« æ‰å¯¹runloopæœ‰äº†ä¸€å®šçš„äº†è§£ï¼Œå¸Œæœ›é€šè¿‡è¿™ç¯‡æ–‡ç« æ¥è®°å½•å¹¶åŠ æ·±å¯¹runloopçš„ç†è§£ã€‚<a href="https://opensource.apple.com/tarballs/CF/">CFRunloopæºä»£ç </a></p>

<h3 id="ä¸€runloopç®€ä»‹">ä¸€ã€RunLoopç®€ä»‹</h3>

<p>RunLoop å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡ç®¡ç†äº†å…¶éœ€è¦å¤„ç†çš„äº‹ä»¶å’Œæ¶ˆæ¯ï¼Œå¹¶æä¾›äº†ä¸€ä¸ªå…¥å£å‡½æ•°æ¥æ‰§è¡Œä¸Šé¢ Event Loop çš„é€»è¾‘ã€‚çº¿ç¨‹æ‰§è¡Œäº†è¿™ä¸ªå‡½æ•°åï¼Œå°±ä¼šä¸€ç›´å¤„äºè¿™ä¸ªå‡½æ•°å†…éƒ¨ â€œæ¥å—æ¶ˆæ¯-&gt;ç­‰å¾…-&gt;å¤„ç†â€ çš„å¾ªç¯ä¸­ï¼Œç›´åˆ°è¿™ä¸ªå¾ªç¯ç»“æŸï¼ˆæ¯”å¦‚ä¼ å…¥ quit çš„æ¶ˆæ¯ï¼‰ï¼Œå‡½æ•°è¿”å›ã€‚</p>

<p>OSX/iOS ç³»ç»Ÿä¸­ï¼Œæä¾›äº†ä¸¤ä¸ªè¿™æ ·çš„å¯¹è±¡ï¼š<code class="highlighter-rouge">NSRunLoop</code> å’Œ <code class="highlighter-rouge">CFRunLoopRef</code>ã€‚</p>

<ul>
  <li><code class="highlighter-rouge">CFRunLoopRef</code> æ˜¯åœ¨ <code class="highlighter-rouge">CoreFoundation</code> æ¡†æ¶å†…çš„ï¼Œå®ƒæä¾›äº†çº¯ C å‡½æ•°çš„ APIï¼Œæ‰€æœ‰è¿™äº› API éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</li>
  <li><code class="highlighter-rouge">NSRunLoop</code> æ˜¯åŸºäº <code class="highlighter-rouge">CFRunLoopRef</code> çš„å°è£…ï¼Œæä¾›äº†é¢å‘å¯¹è±¡çš„ APIï¼Œä½†æ˜¯è¿™äº› API ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</li>
</ul>

<h3 id="äºŒrunloopä¸çº¿ç¨‹å…³ç³»">äºŒã€RunLoopä¸çº¿ç¨‹å…³ç³»</h3>

<p>RunLoop å’Œçº¿ç¨‹æ˜¯æ¯æ¯ç›¸å…³çš„ï¼Œæˆ‘ä»¬çŸ¥é“çº¿ç¨‹çš„ä½œç”¨æ˜¯ç”¨æ¥æ‰§è¡Œç‰¹å®šçš„ä¸€ä¸ªæˆ–å¤šä¸ªä»»åŠ¡ï¼Œåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œçº¿ç¨‹æ‰§è¡Œå®Œä¹‹åå°±ä¼šé€€å‡ºï¼Œå°±ä¸èƒ½å†æ‰§è¡Œä»»åŠ¡äº†ã€‚è¿™æ—¶æˆ‘ä»¬å°±éœ€è¦é‡‡ç”¨ä¸€ç§æ–¹å¼æ¥è®©çº¿ç¨‹èƒ½å¤Ÿä¸æ–­åœ°å¤„ç†ä»»åŠ¡ï¼Œå¹¶ä¸é€€å‡ºã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å°±æœ‰äº† RunLoopã€‚</p>

<p>è‹¹æœä¸å…è®¸ç›´æ¥åˆ›å»º RunLoopï¼Œå®ƒåªæä¾›äº†ä¸¤ä¸ªè‡ªåŠ¨è·å–çš„å‡½æ•°ï¼š<code class="highlighter-rouge">CFRunLoopGetMain()</code> å’Œ <code class="highlighter-rouge">CFRunLoopGetCurrent()</code>ã€‚ è¿™ä¸¤ä¸ªå‡½æ•°æºç ä¸ºä¸‹é¢è¿™æ ·:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å…¨å±€çš„Dictionaryï¼Œkey æ˜¯ pthread_tï¼Œ value æ˜¯ CFRunLoopRef
static CFMutableDictionaryRef __CFRunLoops = NULL;
// è®¿é—® __CFRunLoops æ—¶çš„é”
static CFSpinLock_t loopsLock = CFSpinLockInit;

CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {
    if (pthread_equal(t, kNilPthreadT)) {
				t = pthread_main_thread_np();
    }
    __CFSpinLock(&amp;loopsLock);
    if (!__CFRunLoops) {
    		// ç¬¬ä¸€æ¬¡è¿›å…¥æ—¶ï¼Œåˆå§‹åŒ–å…¨å±€ __CFRunLoopsï¼Œå¹¶å…ˆä¸ºä¸»çº¿ç¨‹åˆ›å»ºä¸€ä¸ª RunLoop
        __CFSpinUnlock(&amp;loopsLock);
				CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);
				CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());
				CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) {
            CFRelease(dict);
        }
				CFRelease(mainLoop);
        __CFSpinLock(&amp;loopsLock);
    }
    // ç›´æ¥ä» __CFRunLoops é‡Œè·å–
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    __CFSpinUnlock(&amp;loopsLock);
    if (!loop) {
    		// è·å–ä¸åˆ°æ—¶ï¼Œåˆ›å»ºä¸€ä¸ª
				CFRunLoopRef newLoop = __CFRunLoopCreate(t);
        __CFSpinLock(&amp;loopsLock);
				loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
				if (!loop) {
	    			CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);
	    			loop = newLoop;
				}
   			 __CFSpinUnlock(&amp;loopsLock);
				CFRelease(newLoop);
    }
    if (pthread_equal(t, pthread_self())) {
    		// æ³¨å†Œä¸€ä¸ªå›è°ƒï¼Œå½“çº¿ç¨‹é”€æ¯æ—¶ï¼Œé¡ºä¾¿ä¹Ÿé”€æ¯å…¶å¯¹åº”çš„ RunLoopã€‚
       	_CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);
        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {
            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (* (void *))__CFFinalizeRunLoop);
        }
    }
    return loop;
}

CFRunLoopRef CFRunLoopGetMain(void) {
    CHECK_FOR_FORK();
    static CFRunLoopRef __main = NULL; // no retain needed
    // pthread_main_thread_np() ä¸ºä¸»çº¿ç¨‹
    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed
    return __main;
}

CFRunLoopRef CFRunLoopGetCurrent(void) {
    CHECK_FOR_FORK();
    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);
    if (rl) return rl;
    // pthread_self() ä¸ºå½“å‰çº¿ç¨‹
    return _CFRunLoopGet0(pthread_self());
}

void CFRunLoopRun(void) {	/* DOES CALLOUT */
    int32_t result;
    do {
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        CHECK_FOR_FORK();
    } while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);
}
</code></pre></div></div>

<p>ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œçº¿ç¨‹å’Œ RunLoop ä¹‹é—´æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œå…¶å…³ç³»æ˜¯ä¿å­˜åœ¨ä¸€ä¸ªå…¨å±€çš„ Dictionary é‡Œã€‚çº¿ç¨‹åˆšåˆ›å»ºæ—¶å¹¶æ²¡æœ‰ RunLoopï¼Œå¦‚æœä½ ä¸ä¸»åŠ¨è·å–ï¼Œé‚£å®ƒä¸€ç›´éƒ½ä¸ä¼šæœ‰ã€‚RunLoop çš„åˆ›å»ºæ˜¯å‘ç”Ÿåœ¨ç¬¬ä¸€æ¬¡è·å–æ—¶ï¼ŒRunLoop çš„é”€æ¯æ˜¯å‘ç”Ÿåœ¨çº¿ç¨‹ç»“æŸæ—¶ã€‚ä½ åªèƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹çš„å†…éƒ¨è·å–å…¶ RunLoopï¼ˆä¸»çº¿ç¨‹é™¤å¤–ï¼‰ã€‚</p>

<p>RunLoopä¸çº¿ç¨‹ä¹‹é—´çš„å…³ç³»å¯†ä¸å¯åˆ†:</p>

<ul>
  <li>çº¿ç¨‹ä¸RunLoopæ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œä¸€ä¸ªçº¿ç¨‹å¯¹åº”ä¸€ä¸ªRunLoopå¯¹è±¡ï¼ŒRunLoopä¸èƒ½è‡ªå·±åˆ›å»ºã€‚</li>
  <li>ä¸»çº¿ç¨‹çš„RunLoopåœ¨åº”ç”¨å¯åŠ¨çš„æ—¶å€™ä¼šè‡ªåŠ¨åˆ›å»ºï¼Œéä¸»çº¿ç¨‹çš„RunLoopéœ€è¦åœ¨è¯¥çº¿ç¨‹è‡ªå·±å¯åŠ¨ã€‚</li>
  <li>RunLoopå¯¹è±¡åœ¨ç¬¬ä¸€æ¬¡è·å–RunLoopæ—¶åˆ›å»ºï¼Œé”€æ¯åˆ™æ˜¯åœ¨çº¿ç¨‹ç»“æŸçš„æ—¶å€™ã€‚</li>
  <li>RunLoopå¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œåªèƒ½åœ¨å½“å‰çº¿ç¨‹ä¸­æ“ä½œå½“å‰çº¿ç¨‹çš„RunLoopï¼Œè€Œä¸èƒ½å»æ“ä½œå…¶ä»–çº¿ç¨‹çš„RunLoopï¼ŒåŒæ—¶ä¹Ÿéœ€è¦é¿å…åœ¨å…¶ä»–çº¿ç¨‹ä¸Šè°ƒç”¨å½“å‰çº¿ç¨‹çš„RunLoopã€‚</li>
</ul>

<h3 id="ä¸‰runloopç›¸å…³ç±»">ä¸‰ã€RunLoopç›¸å…³ç±»</h3>

<p>åœ¨ <code class="highlighter-rouge">CoreFoundation</code> é‡Œé¢å…³äº RunLoop æœ‰5ä¸ªç±»:</p>

<ol>
  <li><code class="highlighter-rouge">CFRunLoopRef</code>ï¼šä»£è¡¨ RunLoop çš„å¯¹è±¡</li>
  <li><code class="highlighter-rouge">CFRunLoopModeRef</code>ï¼šä»£è¡¨ RunLoop çš„è¿è¡Œæ¨¡å¼</li>
  <li><code class="highlighter-rouge">CFRunLoopSourceRef</code>ï¼šå°±æ˜¯ RunLoop æ¨¡å‹å›¾ä¸­æåˆ°çš„è¾“å…¥æº / äº‹ä»¶æº</li>
  <li><code class="highlighter-rouge">CFRunLoopTimerRef</code>ï¼šå°±æ˜¯ RunLoop æ¨¡å‹å›¾ä¸­æåˆ°çš„å®šæ—¶æº</li>
  <li><code class="highlighter-rouge">CFRunLoopObserverRef</code>ï¼šè§‚å¯Ÿè€…ï¼Œèƒ½å¤Ÿç›‘å¬ RunLoop çš„çŠ¶æ€æ”¹å˜</li>
</ol>

<p>å…¶ä¸­ <code class="highlighter-rouge">CFRunLoopModeRef</code> ç±»å¹¶æ²¡æœ‰å¯¹å¤–æš´éœ²ï¼Œåªæ˜¯é€šè¿‡ <code class="highlighter-rouge">CFRunLoopRef </code>çš„æ¥å£è¿›è¡Œäº†å°è£…ã€‚ä»–ä»¬çš„å…³ç³»å¦‚ä¸‹:</p>

<p><img src="https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/runloop-class.png" alt="runloop-class" /></p>

<p>ä¸€ä¸ªRunLoopå¯¹è±¡<code class="highlighter-rouge">CFRunLoopRef</code>ä¸­åŒ…å«è‹¥å¹²ä¸ªè¿è¡Œæ¨¡å¼<code class="highlighter-rouge">CFRunLoopModeRef</code>ã€‚è€Œæ¯ä¸€ä¸ªè¿è¡Œæ¨¡å¼ä¸‹åˆåŒ…å«è‹¥å¹²ä¸ªè¾“å…¥æº<code class="highlighter-rouge">CFRunLoopSourceRef</code>ã€å®šæ—¶æº<code class="highlighter-rouge">CFRunLoopTimerRef</code>ã€è§‚å¯Ÿè€…<code class="highlighter-rouge">CFRunLoopObserverRef</code>ã€‚</p>

<ul>
  <li>
    <p>æ¯æ¬¡ RunLoop å¯åŠ¨æ—¶ï¼Œåªèƒ½æŒ‡å®šå…¶ä¸­ä¸€ä¸ªè¿è¡Œæ¨¡å¼<code class="highlighter-rouge">CFRunLoopModeRef</code>ï¼Œè¿™ä¸ªè¿è¡Œæ¨¡å¼<code class="highlighter-rouge">CFRunLoopModeRef</code>è¢«ç§°ä½œå½“å‰è¿è¡Œæ¨¡å¼<code class="highlighter-rouge">CurrentMode</code>ã€‚</p>
  </li>
  <li>
    <p>å¦‚æœéœ€è¦åˆ‡æ¢è¿è¡Œæ¨¡å¼<code class="highlighter-rouge">CFRunLoopModeRef</code>ï¼Œåªèƒ½é€€å‡ºå½“å‰ RunLoopï¼Œå†é‡æ–°æŒ‡å®šä¸€ä¸ªè¿è¡Œæ¨¡å¼<code class="highlighter-rouge">CFRunLoopModeRef</code>è¿›å…¥ã€‚</p>
  </li>
  <li>
    <p>ä¸»è¦æ˜¯ä¸ºäº†åˆ†éš”å¼€ä¸åŒç»„çš„è¾“å…¥æº<code class="highlighter-rouge">CFRunLoopSourceRef</code>ã€å®šæ—¶æº<code class="highlighter-rouge">CFRunLoopTimerRef</code>ã€è§‚å¯Ÿè€…<code class="highlighter-rouge">CFRunLoopObserverRef</code>ï¼Œè®©å…¶äº’ä¸å½±å“ã€‚</p>
  </li>
</ul>

<h4 id="31-cfrunloopref">3.1 CFRunLoopRef</h4>

<p><code class="highlighter-rouge">CFRunLoopRef</code> æ˜¯ <code class="highlighter-rouge">Core Foundation</code> æ¡†æ¶ä¸‹ RunLoop å¯¹è±¡ç±»ã€‚æˆ‘ä»¬å¯é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¥è·å– RunLoop å¯¹è±¡ï¼š</p>

<p>Core Foundation æ¡†æ¶ä¸‹:</p>

<ul>
  <li><code class="highlighter-rouge">CFRunLoopGetCurrent();</code> // è·å¾—å½“å‰çº¿ç¨‹çš„ RunLoop å¯¹è±¡</li>
  <li><code class="highlighter-rouge">CFRunLoopGetMain(); </code> // è·å¾—ä¸»çº¿ç¨‹çš„ RunLoop å¯¹è±¡</li>
</ul>

<p>åœ¨Foundationæ¡†æ¶ä¸‹</p>

<ul>
  <li><code class="highlighter-rouge">[NSRunLoop currentRunLoop];</code> // è·å¾—å½“å‰çº¿ç¨‹çš„ RunLoop å¯¹è±¡</li>
  <li><code class="highlighter-rouge">[NSRunLoop mainRunLoop];</code> // è·å¾—ä¸»çº¿ç¨‹çš„ RunLoop å¯¹è±¡</li>
</ul>

<p><code class="highlighter-rouge">CFRunLoopRef</code>æºç ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct __CFRunLoop {
    ...
    CFMutableSetRef _commonModes; 			// Set é›†åˆ
    CFMutableSetRef _commonModeItems;   // Set&lt;Source/Observer/Timer&gt; é›†åˆ 
    CFRunLoopModeRef _currentMode;			// Current Runloop Mode
    CFMutableSetRef _modes;							// Set é›†åˆ
    ...
};
</code></pre></div></div>

<h4 id="32-cfrunloopmoderef">3.2 CFRunLoopModeRef</h4>

<p>ç³»ç»Ÿé»˜è®¤å®šä¹‰äº†å¤šç§è¿è¡Œæ¨¡å¼<code class="highlighter-rouge">CFRunLoopModeRef</code>ï¼Œå¦‚ä¸‹ï¼š</p>

<ol>
  <li><strong><code class="highlighter-rouge">kCFRunLoopDefaultMode</code></strong>ï¼šAppçš„é»˜è®¤è¿è¡Œæ¨¡å¼ï¼Œé€šå¸¸ä¸»çº¿ç¨‹æ˜¯åœ¨è¿™ä¸ªè¿è¡Œæ¨¡å¼ä¸‹è¿è¡Œ</li>
  <li><strong><code class="highlighter-rouge">UITrackingRunLoopMode</code></strong>ï¼šè·Ÿè¸ªç”¨æˆ·äº¤äº’äº‹ä»¶ï¼ˆç”¨äº ScrollView è¿½è¸ªè§¦æ‘¸æ»‘åŠ¨ï¼Œä¿è¯ç•Œé¢æ»‘åŠ¨æ—¶ä¸å—å…¶ä»–Modeå½±å“ï¼‰</li>
  <li><code class="highlighter-rouge">UIInitializationRunLoopMode</code>ï¼šåœ¨åˆšå¯åŠ¨Appæ—¶ç¬¬è¿›å…¥çš„ç¬¬ä¸€ä¸ª Modeï¼Œå¯åŠ¨å®Œæˆåå°±ä¸å†ä½¿ç”¨</li>
  <li><code class="highlighter-rouge">GSEventReceiveRunLoopMode</code>ï¼šæ¥å—ç³»ç»Ÿå†…éƒ¨äº‹ä»¶ï¼Œé€šå¸¸ç”¨ä¸åˆ°</li>
  <li><strong><code class="highlighter-rouge">kCFRunLoopCommonModes</code></strong>ï¼šä¼ªæ¨¡å¼ï¼Œä¸æ˜¯ä¸€ç§çœŸæ­£çš„è¿è¡Œæ¨¡å¼ï¼ˆåè¾¹ä¼šç”¨åˆ°ï¼‰</li>
</ol>

<p>å…¶ä¸­<strong><code class="highlighter-rouge">kCFRunLoopDefaultMode</code></strong>ã€<strong><code class="highlighter-rouge">UITrackingRunLoopMode</code></strong>ã€<strong><code class="highlighter-rouge">kCFRunLoopCommonModes</code></strong>æ˜¯æˆ‘ä»¬å¼€å‘ä¸­éœ€è¦ç”¨åˆ°çš„æ¨¡å¼ã€‚</p>

<p><code class="highlighter-rouge">CFRunLoopModeRef</code>æºç å¦‚ä¸‹ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct __CFRunLoopMode {
    ...
    CFStringRef _name;  							// Mode Name, ä¾‹å¦‚ @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;				// Set é›†åˆ
    CFMutableSetRef _sources1;				// Set é›†åˆ
    CFMutableArrayRef _observers;     // Array æ•°ç»„
    CFMutableArrayRef _timers;				// Array æ•°ç»„
    CFMutableDictionaryRef _portToV1SourceMap;
    __CFPortSet _portSet;
    CFIndex _observerMask;
		....
    uint64_t _timerSoftDeadline; /* TSR */
    uint64_t _timerHardDeadline; /* TSR */
};
</code></pre></div></div>

<p>ä¸€ä¸ª RunLoop å¯¹è±¡åŒ…å«è‹¥å¹²ä¸ª Mode å¯¹è±¡ï¼Œæ¯ä¸ª Mode åˆåŒ…å«è‹¥å¹²ä¸ª Source/Timer/Observerï¼ŒRunLoop ä¸€æ¬¡è¿è¡Œåªèƒ½åœ¨ä¸€ä¸ª Mode ä¹‹ä¸‹ï¼Œå¦‚æœéœ€è¦åˆ‡æ¢ Modeï¼Œéœ€è¦é€€å‡º RunLoop æ‰èƒ½é‡æ–°æŒ‡å®šä¸€ä¸ª Modeã€‚è¿™æ ·åšä¸»è¦æ˜¯ä¸ºäº†åˆ†éš”å¼€ä¸åŒç»„Source/Timer/Observerï¼Œè®©å…¶äº’ä¸å½±å“ã€‚</p>

<h4 id="33-cfrunlooptimerref">3.3 CFRunLoopTimerRef</h4>

<p><code class="highlighter-rouge">CFRunLoopTimerRef</code>æ˜¯å®šæ—¶æºï¼ˆRunLoopæ¨¡å‹å›¾ä¸­æåˆ°è¿‡ï¼‰ï¼Œç†è§£ä¸ºåŸºäºæ—¶é—´çš„è§¦å‘å™¨ï¼ŒåŸºæœ¬ä¸Šå°±æ˜¯<code class="highlighter-rouge">NSTimer</code>ã€‚</p>

<p>ä¸€ä¸ªæ¯”è¾ƒå¸¸è§çš„é—®é¢˜ï¼šæ»‘åŠ¨tableViewæ—¶ï¼Œå®šæ—¶å™¨è¿˜ä¼šç”Ÿæ•ˆå—ï¼Ÿ</p>

<p>é»˜è®¤æƒ…å†µä¸‹RunLoopè¿è¡Œåœ¨<code class="highlighter-rouge">kCFRunLoopDefaultMode</code>ä¸‹ï¼Œè€Œå½“æ»‘åŠ¨tableViewæ—¶ï¼ŒRunLoopåˆ‡æ¢åˆ°<code class="highlighter-rouge">UITrackingRunLoopMode</code>ï¼Œè€ŒTimeræ˜¯åœ¨<code class="highlighter-rouge">kCFRunLoopDefaultMode</code>ä¸‹çš„ï¼Œå°±æ— æ³•æ¥å—å¤„ç†Timerçš„äº‹ä»¶ã€‚</p>

<p>æ€ä¹ˆå»è§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼ŸæŠŠTimeræ·»åŠ åˆ°UITrackingRunLoopModeä¸Šå¹¶ä¸èƒ½è§£å†³é—®é¢˜ï¼Œå› ä¸ºè¿™æ ·åœ¨é»˜è®¤æƒ…å†µä¸‹å°±æ— æ³•æ¥å—å®šæ—¶å™¨äº‹ä»¶äº†ã€‚ æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠTimeråŒæ—¶æ·»åŠ åˆ°<code class="highlighter-rouge">UITrackingRunLoopMode</code>å’Œ<code class="highlighter-rouge">kCFRunLoopDefaultMode</code>ä¸Šã€‚
 é‚£ä¹ˆå¦‚ä½•æŠŠtimeråŒæ—¶æ·»åŠ åˆ°å¤šä¸ªmodeä¸Šå‘¢ï¼Ÿå°±è¦ç”¨åˆ°<code class="highlighter-rouge">NSRunLoopCommonModes</code>äº†ã€‚</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre></div></div>

<p>Timerå°±è¢«æ·»åŠ åˆ°å¤šä¸ªmodeä¸Šï¼Œè¿™æ ·å³ä½¿RunLoopç”±<code class="highlighter-rouge">kCFRunLoopDefaultMode</code>åˆ‡æ¢åˆ°<code class="highlighter-rouge">UITrackingRunLoopMode</code>ä¸‹ï¼Œä¹Ÿä¸ä¼šå½±å“æ¥æ”¶Timeräº‹ä»¶ã€‚</p>

<h4 id="34-cfrunloopsourceref">3.4 CFRunLoopSourceRef</h4>

<p><code class="highlighter-rouge">CFRunLoopSourceRef</code> æ˜¯äº‹ä»¶äº§ç”Ÿçš„åœ°æ–¹ã€‚Sourceæœ‰ä¸¤ä¸ªç‰ˆæœ¬ï¼šSource0 å’Œ Source1</p>

<ul>
  <li>Source0 åªåŒ…å«äº†ä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œå®ƒå¹¶ä¸èƒ½ä¸»åŠ¨è§¦å‘äº‹ä»¶ã€‚ä½¿ç”¨æ—¶ï¼Œä½ éœ€è¦å…ˆè°ƒç”¨ <code class="highlighter-rouge">CFRunLoopSourceSignal(source)</code>ï¼Œå°†è¿™ä¸ª Source æ ‡è®°ä¸ºå¾…å¤„ç†ï¼Œç„¶åæ‰‹åŠ¨è°ƒç”¨ <code class="highlighter-rouge">CFRunLoopWakeUp(runloop) </code>æ¥å”¤é†’ RunLoopï¼Œè®©å…¶å¤„ç†è¿™ä¸ªäº‹ä»¶ã€‚</li>
  <li>Source1 åŒ…å«äº†ä¸€ä¸ª mach_port å’Œä¸€ä¸ªå›è°ƒï¼ˆå‡½æ•°æŒ‡é’ˆï¼‰ï¼Œè¢«ç”¨äºé€šè¿‡å†…æ ¸å’Œå…¶ä»–çº¿ç¨‹ç›¸äº’å‘é€æ¶ˆæ¯ã€‚è¿™ç§ Source èƒ½ä¸»åŠ¨å”¤é†’ RunLoop çš„çº¿ç¨‹ï¼Œå…¶åŸç†åœ¨ä¸‹é¢ä¼šè®²åˆ°ã€‚</li>
</ul>

<h4 id="35-cfrunloopobserverref">3.5 CFRunLoopObserverRef</h4>

<p><code class="highlighter-rouge">CFRunLoopObserverRef</code>æ˜¯è§‚å¯Ÿè€…ï¼Œç”¨æ¥ç›‘å¬RunLoopçš„çŠ¶æ€æ”¹å˜ã€‚</p>

<p><code class="highlighter-rouge">CFRunLoopObserverRef</code>å¯ä»¥ç›‘å¬çš„çŠ¶æ€æ”¹å˜æœ‰ä»¥ä¸‹å‡ ç§ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL &lt;&lt; 0),               // å³å°†è¿›å…¥RunLoopï¼š1
    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),        // å³å°†å¤„ç†Timerï¼š2    
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),       // å³å°†å¤„ç†Sourceï¼š4
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),       // å³å°†è¿›å…¥ä¼‘çœ ï¼š32
    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),        // å³å°†ä»ä¼‘çœ ä¸­å”¤é†’ï¼š64
    kCFRunLoopExit = (1UL &lt;&lt; 7),                // å³å°†ä»Loopä¸­é€€å‡ºï¼š128
    kCFRunLoopAllActivities = 0x0FFFFFFFU       // ç›‘å¬å…¨éƒ¨çŠ¶æ€æ”¹å˜  
};
</code></pre></div></div>

<h3 id="å››runloopåŸç†">å››ã€RunLoopåŸç†</h3>

<p>æ ¹æ®è‹¹æœåœ¨<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">æ–‡æ¡£</a>é‡Œçš„è¯´æ˜ï¼ŒRunLoop å†…éƒ¨çš„é€»è¾‘å¤§è‡´å¦‚ä¸‹:</p>

<p><img src="https://raw.githubusercontent.com/limeng99/limeng99.github.io/master/assets/img/screenshots/runloop-chart.png" alt="runloop-chart" /></p>

<p>å…¶å†…éƒ¨æºç æ•´ç†å¦‚ä¸‹ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ç”¨DefaultModeå¯åŠ¨
void CFRunLoopRun(void) {	/* DOES CALLOUT */
    int32_t result;
    do {
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        CHECK_FOR_FORK();
    } while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);
}

// ç”¨æŒ‡å®šçš„Modeå¯åŠ¨ï¼Œå…è®¸è®¾ç½®RunLoopè¶…æ—¶æ—¶é—´
SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}

// RunLoopçš„å®ç°
SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */
    CHECK_FOR_FORK();
    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;
    __CFRunLoopLock(rl);
    // é¦–å…ˆæ ¹æ®modeNameæ‰¾åˆ°å¯¹åº”mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) {
				Boolean did = false;
				if (currentMode) __CFRunLoopModeUnlock(currentMode);
				__CFRunLoopUnlock(rl);
				return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);
    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;
    rl-&gt;_currentMode = currentMode;
    int32_t result = kCFRunLoopRunFinished;
    
		// é€šçŸ¥ Observers: RunLoop å³å°†è¿›å…¥ loop
		if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
		// 
		result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
		if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
  	__CFRunLoopModeUnlock(currentMode);
    __CFRunLoopPopPerRunData(rl, previousPerRun);
		rl-&gt;_currentMode = previousMode;
    __CFRunLoopUnlock(rl);
    return result;
}

static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {
    uint64_t startTSR = mach_absolute_time();

    if (__CFRunLoopIsStopped(rl)) {
        __CFRunLoopUnsetStopped(rl);
	return kCFRunLoopRunStopped;
    } else if (rlm-&gt;_stopped) {
	rlm-&gt;_stopped = false;
	return kCFRunLoopRunStopped;
    }
    
    mach_port_name_t dispatchPort = MACH_PORT_NULL;
    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));
    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();
    
#if USE_DISPATCH_SOURCE_FOR_TIMERS
    mach_port_name_t modeQueuePort = MACH_PORT_NULL;
    if (rlm-&gt;_queue) {
        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);
        if (!modeQueuePort) {
            CRASH("Unable to get port for run loop mode queue (%d)", -1);
        }
    }
#endif
    
    dispatch_source_t timeout_timer = NULL;
    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));
    if (seconds &lt;= 0.0) { // instant timeout
        seconds = 0.0;
        timeout_context-&gt;termTSR = 0ULL;
    } else if (seconds &lt;= TIMER_INTERVAL_LIMIT) {
	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);
	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
        dispatch_retain(timeout_timer);
	timeout_context-&gt;ds = timeout_timer;
	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);
	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);
	dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context
	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);
        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);
        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);
        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);
        dispatch_resume(timeout_timer);
    } else { // infinite timeout
        seconds = 9999999999.0;
        timeout_context-&gt;termTSR = UINT64_MAX;
    }

    Boolean didDispatchPortLastTime = true;
    int32_t retVal = 0;
    do {
        uint8_t msg_buffer[3 * 1024];
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
        mach_msg_header_t *msg = NULL;
        mach_port_t livePort = MACH_PORT_NULL;
#elif DEPLOYMENT_TARGET_WINDOWS
        HANDLE livePort = NULL;
        Boolean windowsMessageReceived = false;
#endif
	__CFPortSet waitSet = rlm-&gt;_portSet;

        __CFRunLoopUnsetIgnoreWakeUps(rl);

        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);
        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);

	__CFRunLoopDoBlocks(rl, rlm);

        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
        if (sourceHandledThisLoop) {
            __CFRunLoopDoBlocks(rl, rlm);
	}

        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);

        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
            msg = (mach_msg_header_t *)msg_buffer;
            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) {
                goto handle_msg;
            }
#elif DEPLOYMENT_TARGET_WINDOWS
            if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) {
                goto handle_msg;
            }
#endif
        }

        didDispatchPortLastTime = false;

	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
	__CFRunLoopSetSleeping(rl);
	// do not do any user callouts after this point (after notifying of sleeping)

        // Must push the local-to-this-activation ports in on every loop
        // iteration, as this mode could be run re-entrantly and we don't
        // want these ports to get serviced.

        __CFPortSetInsert(dispatchPort, waitSet);
        
	__CFRunLoopModeUnlock(rlm);
	__CFRunLoopUnlock(rl);

#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
#if USE_DISPATCH_SOURCE_FOR_TIMERS
        do {
            if (kCFUseCollectableAllocator) {
                objc_clear_stack(0);
                memset(msg_buffer, 0, sizeof(msg_buffer));
            }
            msg = (mach_msg_header_t *)msg_buffer;
            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);
            
            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) {
                // Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.
                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));
                if (rlm-&gt;_timerFired) {
                    // Leave livePort as the queue port, and service timers below
                    rlm-&gt;_timerFired = false;
                    break;
                } else {
                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
                }
            } else {
                // Go ahead and leave the inner loop.
                break;
            }
        } while (1);
#else
        if (kCFUseCollectableAllocator) {
            objc_clear_stack(0);
            memset(msg_buffer, 0, sizeof(msg_buffer));
        }
        msg = (mach_msg_header_t *)msg_buffer;
        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);
#endif
        
        
#elif DEPLOYMENT_TARGET_WINDOWS
        // Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.
        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);
#endif
        
        __CFRunLoopLock(rl);
        __CFRunLoopModeLock(rlm);

        // Must remove the local-to-this-activation ports in on every loop
        // iteration, as this mode could be run re-entrantly and we don't
        // want these ports to get serviced. Also, we don't want them left
        // in there if this function returns.

        __CFPortSetRemove(dispatchPort, waitSet);
        
        __CFRunLoopSetIgnoreWakeUps(rl);

        // user callouts now OK again
	__CFRunLoopUnsetSleeping(rl);
	if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);

        handle_msg:;
        __CFRunLoopSetIgnoreWakeUps(rl);

#if DEPLOYMENT_TARGET_WINDOWS
        if (windowsMessageReceived) {
            // These Win32 APIs cause a callout, so make sure we're unlocked first and relocked after
            __CFRunLoopModeUnlock(rlm);
	    __CFRunLoopUnlock(rl);

            if (rlm-&gt;_msgPump) {
                rlm-&gt;_msgPump();
            } else {
                MSG msg;
                if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) {
                    TranslateMessage(&amp;msg);
                    DispatchMessage(&amp;msg);
                }
            }
            
            __CFRunLoopLock(rl);
	    __CFRunLoopModeLock(rlm);
 	    sourceHandledThisLoop = true;
            
            // To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced
            // Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we're just checking to see if the things are signalled right now -- we will wait on them again later.
            // NOTE: Ignore the dispatch source (it's not in the wait set anymore) and also don't run the observers here since we are polling.
            __CFRunLoopSetSleeping(rl);
            __CFRunLoopModeUnlock(rlm);
            __CFRunLoopUnlock(rl);
            
            __CFRunLoopWaitForMultipleObjects(waitSet, NULL, 0, 0, &amp;livePort, NULL);
            
            __CFRunLoopLock(rl);
            __CFRunLoopModeLock(rlm);            
            __CFRunLoopUnsetSleeping(rl);
            // If we have a new live port then it will be handled below as normal
        }
        
        
#endif
        if (MACH_PORT_NULL == livePort) {
            CFRUNLOOP_WAKEUP_FOR_NOTHING();
            // handle nothing
        } else if (livePort == rl-&gt;_wakeUpPort) {
            CFRUNLOOP_WAKEUP_FOR_WAKEUP();
            // do nothing on Mac OS
#if DEPLOYMENT_TARGET_WINDOWS
            // Always reset the wake up port, or risk spinning forever
            ResetEvent(rl-&gt;_wakeUpPort);
#endif
        }
#if USE_DISPATCH_SOURCE_FOR_TIMERS
        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) {
            CFRUNLOOP_WAKEUP_FOR_TIMER();
            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                // Re-arm the next timer, because we apparently fired early
                __CFArmNextTimerInMode(rlm, rl);
            }
        }
#endif
#if USE_MK_TIMER_TOO
        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) {
            CFRUNLOOP_WAKEUP_FOR_TIMER();
            // On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.
            // In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754
            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
                // Re-arm the next timer
                __CFArmNextTimerInMode(rlm, rl);
            }
        }
#endif
        else if (livePort == dispatchPort) {
            CFRUNLOOP_WAKEUP_FOR_DISPATCH();
            __CFRunLoopModeUnlock(rlm);
            __CFRunLoopUnlock(rl);
            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);
#if DEPLOYMENT_TARGET_WINDOWS
            void *msg = 0;
#endif
            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);
	        __CFRunLoopLock(rl);
	        __CFRunLoopModeLock(rlm);
 	        sourceHandledThisLoop = true;
            didDispatchPortLastTime = true;
        } else {
            CFRUNLOOP_WAKEUP_FOR_SOURCE();
            // Despite the name, this works for windows handles as well
            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
            if (rls) {
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
		mach_msg_header_t *reply = NULL;
		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;
		if (NULL != reply) {
		    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
		}
#elif DEPLOYMENT_TARGET_WINDOWS
                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
#endif
	    }
        } 
#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI
        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
#endif
        
	__CFRunLoopDoBlocks(rl, rlm);
        

	if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
	    retVal = kCFRunLoopRunHandledSource;
        } else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) {
            retVal = kCFRunLoopRunTimedOut;
	} else if (__CFRunLoopIsStopped(rl)) {
            __CFRunLoopUnsetStopped(rl);
	    retVal = kCFRunLoopRunStopped;
	} else if (rlm-&gt;_stopped) {
	    rlm-&gt;_stopped = false;
	    retVal = kCFRunLoopRunStopped;
	} else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
	    retVal = kCFRunLoopRunFinished;
	}
    } while (0 == retVal);

    if (timeout_timer) {
        dispatch_source_cancel(timeout_timer);
        dispatch_release(timeout_timer);
    } else {
        free(timeout_context);
    }

    return retVal;
}
</code></pre></div></div>

:ET